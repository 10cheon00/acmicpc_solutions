/*
 * 2624 동전 바꿔주기
 * 골드V

 11
 3
 1 5
 3 2
 5 2
    | 0  1  2  3  4  5  6  7  8  9 10 11
 ---+-----------------------------------
  1 | 1  1  1  1  1  1  0  0  0  0  0  0
  3 | 1  1  1  2  2  2  2  2  2  1  1  1
  5 | 1  1  1  2  2  3  3  3  4  3  4  4

 동전문제의 응용.
 개수 제한이 걸린 동전을 조합할 때 주어진 개수보다 많이 고르지 않도록 해야 한다.
 1, 3원 짜리로 8원을 만든다고 할 때 3원은 2개가 주어져 있으니까 다음의 경우를 모두 더하면 된다.
 1원 짜리로 8원 만드는 경우의 수 + 1원 짜리 5개와 3원 짜리 1개로 만드는 경우의 수 + 1원 짜리 2개와 3원 짜리 2개로 만드는 경우의 수
 현재 위치의 동전을 쓰지 않는 경우 부터 최대 개수까지 쓰는 경우의 수를 모두 더해야 한다.

 1, 3, 5원 짜리로 10원을 만드는 경우의 수는 4다.
 5원 짜리 0개) 1, 3원 짜리로 10원을 만드는 경우의 수 = 1
 5원 짜리 1개) 1, 3원 짜리로 10-5=5원을 만드는 경우의 수 = 2
 5원 짜리 1개) 1, 3원 짜리로 10-10=0원을 만드는 경우의 수 = 1
 이 과정을 거치면 4개가 나온다.
 */
#include <iostream>
int main()
{
    int T, K, value[101], count[101];
    scanf("%d %d", &T, &K);
    int **dp = new int *[K + 1];
    dp[0] = new int[T + 1]{0};
    for (int i = 1; i <= K; i++)
    {
        int P, N;
        scanf("%d %d", &P, &N);
        value[i] = P;
        count[i] = N;
        dp[i] = new int[T + 1]{0};
    }
    dp[0][0] = 1;
    for (int i = 1; i <= K; i++)
    {
        dp[i][0] = 1;
        for (int j = 1; j <= T; j++)
        {
            for (int k = 0; k <= count[i]; k++)
            {
                if (j < value[i] * k)
                    break;
                dp[i][j] += dp[i - 1][j - value[i] * k];
            }
            printf("%3d", dp[i][j]);
        }
        puts("");
    }
    printf("%d", dp[K][T] ? dp[K][T] : 0);
}
